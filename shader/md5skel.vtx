/****************************************************************************
 *                                                                          *
 * This file is part of the Asteria project.                                *
 * Copyright (C) 2011 Samuel C. Payson, Akanksha Vyas                       *
 *                                                                          *
 * Asteria is free software: you can redistribute it and/or modify it under *
 * the terms of the GNU General Public License as published by the Free     *
 * Software Foundation, either version 3 of the License, or (at your        *
 * option) any later version.                                               *
 *                                                                          *
 * Asteria is distributed in the hope that it will be useful, but WITHOUT   *
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or    *
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License    *
 * for more details.                                                        *
 *                                                                          *
 * You should have received a copy of the GNU General Public License along  *
 * with Asteria. If not, see <http://www.gnu.org/licenses/>.                *
 *                                                                          *
 ****************************************************************************/

/* md5skel.vtx */
uniform vec4 jQuat[64];

uniform vec3 jPos[64];

attribute vec4  wJoints;
attribute vec4  wBiases;
attribute mat4  wPositions;
attribute mat4  wNormals;

varying vec3 normal;

vec3 qtRotate( vec4 q, vec3 v ) {
   float Dot   = -dot( q.xyz, v );
   vec3  conj  = -1.0 * q.xyz;
   vec3 intVec = ( q.w * v ) + cross( q.xyz, v );

   return ( q.w * intVec ) + ( Dot * conj ) + cross( intVec, conj );
}

void main() {
   vec3 pos[4];
   vec3 norm[4];
   for ( int i = 0; i < 4; ++i ) {
      int jIdx = int( wJoints[i] );
      if ( jIdx != -1 ) {
         pos[i]  = jPos[jIdx]
                 + qtRotate( jQuat[jIdx], wPositions[i].xyz );
         norm[i] = qtRotate( jQuat[jIdx], wNormals[i].xyz );
      } else {
         break;
      }
   }

   normal = gl_NormalMatrix
          * ( ( norm[0] * wBiases[0] ) + ( norm[1] * wBiases[1] )
            + ( norm[2] * wBiases[2] ) + ( norm[3] * wBiases[3] ) );

   gl_Position = gl_ModelViewProjectionMatrix
               * vec4( ( pos[0] * wBiases[0] ) + ( pos[1] * wBiases[1] )
                     + ( pos[2] * wBiases[2] ) + ( pos[3] * wBiases[3] ), 1.0 );
}
